{
    "collab_server" : "",
    "contents" : "#' Results from drawing different color balls from an urn\n#'\n#' @param n.iter The number of iterations in the monte carlo simulation (integer > 0)\n#' @param n.colors The number of different colored balls (integer > 0)\n#' @param n.balls The count of each color balls (vector of integers with same length as \\code{n.colors})\n#' @param n.drawn The number of balls drawn from the urn in each iteration\n#' @param replacement Are the balls placed back in the urn after they're drawn? (defaults to \\code{FALSE})\n#' @param collapse Should the return be the draws or the count of each color? (defaults to \\code{FALSE})\n#' @param parallel Should the simulation take advantage of multiple cores (defaults to \\code{FALSE} -\n#'   highly recommended if \\code{n.iter > 1e5})\n#'\n#' @return If \\code{collapse == TRUE} the return is a \\code{n.iter x n.colors} integer matrix\n#'   where each row is the count of the colors of balls drawn. Otherwise, the return is a\n#'   \\code{n.iter x n.drawn} integer matrix where each row is the order that colors were drawn in.\n#' @export\n#'\ndraw.urn = function(n.iter = 1e5, n.colors = 2, n.balls = c(10,10),\n                    n.drawn = 5, replacement = FALSE,\n                    collapse = FALSE, parallel = FALSE) {\n  stopifnot(n.iter %% 1 == 0 & n.iter > 0)\n  stopifnot(n.colors %% 1 == 0 & n.colors > 0)\n  stopifnot(all(n.balls %% 1 == 0) & all(n.balls > 0))\n  stopifnot(length(n.balls) == n.colors)\n  stopifnot(n.drawn %% 1 == 0 & n.drawn > 0)\n  urn = unlist(lapply(seq_len(n.colors), FUN = function(i) rep(i, n.balls[i])))\n  total.balls = sum(n.balls)\n  if(!parallel) {\n    results = lapply(seq_len(n.iter), FUN = function(i) {\n      indices = sample(seq_len(total.balls), size = n.drawn, replace = replacement)\n      urn[indices]\n    })\n  } else {\n    results = mclapply(seq_len(n.iter), FUN = function(i) {\n      indices = sample(seq_len(total.balls), size = n.drawn, replace = replacement)\n      urn[indices]\n    })\n  }\n  if(collapse) {\n    return(t(sapply(results, FUN = function(x) {\n      vapply(seq_len(n.colors), function(i) sum(x == i),1)\n    })))\n  }\n  return(do.call(rbind, results))\n}\n",
    "created" : 1476125335249.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4115418580",
    "id" : "4A43FC0B",
    "lastKnownWriteTime" : 1476127365,
    "last_content_update" : 1476127365526,
    "path" : "~/Documents/RProjects/Clancy.Functions/R/draw.urn.r",
    "project_path" : "R/draw.urn.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}