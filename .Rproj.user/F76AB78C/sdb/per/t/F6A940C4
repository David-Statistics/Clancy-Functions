{
    "collab_server" : "",
    "contents" : "#' Results of rolling dice\n#'\n#' @param n.iter The number of iterations in the monte carlo simulation (integer > 0)\n#' @param n.dice The number of dice that should be rolled on each trial (integer > 0)\n#' @param sides The number of sides on each die (integer > 0)\n#' @param sum.dice Should the result be the sum of the dice on each iteration (defaults to \\code{FALSE})\n#' @param parallel Should the simulation take advantage of multiple cores (defaults to \\code{FALSE} -\n#'   highly recommended if \\code{n.iter > 1e5})\n#' @return If \\code{sum.dice == TRUE} then the return is a vector of \\code{n.iter} integer entries\n#'   else the return is a \\code{n.iter x n.dice} integer matrix\n#' @export\n#'\nroll.dice = function(n.iter = 1e5, n.dice = 1, sides = 6,\n                     sum.dice = FALSE, parallel = FALSE) {\n  stopifnot(n.iter %% 1 == 0 & n.iter > 0)\n  stopifnot(n.dice %% 1 == 0 & n.dice > 0)\n  stopifnot(sides %% 1 == 0 & sides > 0)\n  if(!parallel) {\n    results = sapply(seq_len(n.iter), FUN = function(i) {sample(seq_len(sides), size = n.dice, rep = TRUE)})\n  } else {\n    results = do.call(cbind, mclapply(seq_len(n.iter), FUN = function(i) {sample(seq_len(sides), size = n.dice, rep = TRUE)}))\n  }\n  if(sum.dice & n.dice > 1) {return(colSums(results))}\n  return(matrix(results, ncol = n.dice))\n}\n",
    "created" : 1476123745353.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1392938213",
    "id" : "F6A940C4",
    "lastKnownWriteTime" : 1476126598,
    "last_content_update" : 1476126598162,
    "path" : "~/Documents/RProjects/Clancy.Functions/R/roll.dice.r",
    "project_path" : "R/roll.dice.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}